/**
 * Vulnerability Scanner for Provider System
 * 
 * Advanced vulnerability scanning system that identifies security vulnerabilities
 * across all providers using OWASP standards, CVE databases, and custom rules.
 */

import { EventEmitter } from 'events';
import * as fs from 'fs/promises';
import * as path from 'path';
import { createHash } from 'crypto';

export interface Vulnerability {
  id: string;
  cveId?: string;
  owaspId?: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category: VulnerabilityCategory;
  vector: AttackVector;
  impact: VulnerabilityImpact;
  exploitability: 'not_defined' | 'unproven' | 'proof_of_concept' | 'functional' | 'high';
  remediationLevel: 'not_defined' | 'official_fix' | 'temporary_fix' | 'workaround' | 'unavailable';
  reportConfidence: 'not_defined' | 'unknown' | 'reasonable' | 'confirmed';
  discoveredAt: Date;
  lastUpdated: Date;
  affectedComponents: string[];
  references: string[];
  remediation: RemediationGuidance;
}

export interface VulnerabilityImpact {
  confidentiality: 'none' | 'partial' | 'complete';
  integrity: 'none' | 'partial' | 'complete';
  availability: 'none' | 'partial' | 'complete';
  scope: 'unchanged' | 'changed';
  privilegesRequired: 'none' | 'low' | 'high';
  userInteraction: 'none' | 'required';
}

export interface AttackVector {
  network: 'network' | 'adjacent' | 'local' | 'physical';
  complexity: 'low' | 'high';
  authentication: 'none' | 'single' | 'multiple';
}

export interface RemediationGuidance {
  steps: string[];
  patches: PatchInfo[];
  workarounds: string[];
  timeline: number; // days
  effort: 'low' | 'medium' | 'high';
  cost: 'low' | 'medium' | 'high';
  riskReduction: number; // percentage
}

export interface PatchInfo {
  version: string;
  releaseDate: Date;
  description: string;
  downloadUrl?: string;
  breaking: boolean;
}

export type VulnerabilityCategory = 
  | 'injection' 
  | 'broken_authentication' 
  | 'sensitive_data_exposure' 
  | 'xml_external_entities' 
  | 'broken_access_control' 
  | 'security_misconfiguration' 
  | 'cross_site_scripting' 
  | 'insecure_deserialization' 
  | 'using_components_with_known_vulnerabilities' 
  | 'insufficient_logging_monitoring'
  | 'server_side_request_forgery'
  | 'cryptographic_failures'
  | 'supply_chain_attacks';

export interface VulnerabilityRule {
  id: string;
  name: string;
  description: string;
  category: VulnerabilityCategory;
  owaspCategory: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  enabled: boolean;
  patterns: VulnerabilityPattern[];
  scan: (provider: any, config: any, context: ScanContext) => Promise<VulnerabilityFinding[]>;
}

export interface VulnerabilityPattern {
  type: 'regex' | 'function' | 'dependency' | 'configuration' | 'network';
  pattern: string | RegExp | Function;
  description: string;
  falsePositiveFilters?: (string | RegExp)[];
}

export interface VulnerabilityFinding {
  ruleId: string;
  location: string;
  evidence: string;
  confidence: 'low' | 'medium' | 'high';
  context?: any;
}

export interface ScanContext {
  providerId: string;
  providerType: string;
  scanType: 'static' | 'dynamic' | 'interactive' | 'dependency';
  depth: 'surface' | 'deep' | 'comprehensive';
  includeExperimental: boolean;
}

export interface ScanResult {
  scanId: string;
  providerId: string;
  providerType: string;
  timestamp: Date;
  duration: number; // milliseconds
  context: ScanContext;
  vulnerabilities: Vulnerability[];
  summary: ScanSummary;
  recommendations: string[];
  nextScanDate: Date;
}

export interface ScanSummary {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  info: number;
  confirmed: number;
  suppressed: number;
  falsePositives: number;
  riskScore: number; // 0-100
}

export class VulnerabilityScanner extends EventEmitter {
  private rules: Map<string, VulnerabilityRule> = new Map();
  private cveDatabase: Map<string, any> = new Map();
  private scanHistory: ScanResult[] = [];
  private suppressedFindings: Set<string> = new Set();

  constructor() {
    super();
    this.initializeVulnerabilityRules();
    this.loadCveDatabase();
  }

  /**
   * Initialize comprehensive vulnerability rules
   */
  private async initializeVulnerabilityRules(): Promise<void> {
    const rules: VulnerabilityRule[] = [
      {
        id: 'OWASP_A01_INJECTION',
        name: 'SQL Injection Vulnerabilities',
        description: 'Detects potential SQL injection vulnerabilities',
        category: 'injection',
        owaspCategory: 'A01:2021 – Broken Access Control',
        severity: 'critical',
        enabled: true,
        patterns: [
          {
            type: 'regex',
            pattern: /["'].*\+.*["']|["'].*\${.*}.*["']/g,
            description: 'String concatenation in SQL queries'
          },
          {
            type: 'function',
            pattern: (code: string) => {
              return code.includes('query(') && !code.includes('prepared') && !code.includes('parameterized');
            },
            description: 'Direct query execution without parameterization'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          if (provider.type === 'database') {
            // Check for unsafe query methods
            const providerCode = provider.toString();
            
            if (providerCode.includes('query(') && !config.security?.parameterizedQueries) {
              findings.push({
                ruleId: 'OWASP_A01_INJECTION',
                location: 'database provider query method',
                evidence: 'Direct SQL query execution without parameterization detected',
                confidence: 'high',
                context: { method: 'query', provider: provider.constructor.name }
              });
            }

            // Check configuration for SQL injection protection
            if (!config.security?.sqlInjectionProtection) {
              findings.push({
                ruleId: 'OWASP_A01_INJECTION',
                location: 'provider configuration',
                evidence: 'SQL injection protection not configured',
                confidence: 'medium',
                context: { configPath: 'security.sqlInjectionProtection' }
              });
            }
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A02_CRYPTO',
        name: 'Cryptographic Failures',
        description: 'Identifies weak cryptographic implementations',
        category: 'cryptographic_failures',
        owaspCategory: 'A02:2021 – Cryptographic Failures',
        severity: 'high',
        enabled: true,
        patterns: [
          {
            type: 'regex',
            pattern: /md5|sha1|des|rc4/gi,
            description: 'Weak cryptographic algorithms'
          },
          {
            type: 'configuration',
            pattern: 'encryption.algorithm',
            description: 'Encryption algorithm configuration'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for weak encryption algorithms
          const weakAlgorithms = ['md5', 'sha1', 'des', 'rc4', 'aes-128-ecb'];
          const configString = JSON.stringify(config).toLowerCase();

          for (const algorithm of weakAlgorithms) {
            if (configString.includes(algorithm)) {
              findings.push({
                ruleId: 'OWASP_A02_CRYPTO',
                location: 'encryption configuration',
                evidence: `Weak cryptographic algorithm detected: ${algorithm}`,
                confidence: 'high',
                context: { algorithm, recommendation: 'Use AES-256-GCM or ChaCha20-Poly1305' }
              });
            }
          }

          // Check for missing encryption
          if (!config.encryption || !config.encryption.enabled) {
            findings.push({
              ruleId: 'OWASP_A02_CRYPTO',
              location: 'encryption configuration',
              evidence: 'Encryption not enabled for sensitive data',
              confidence: 'high',
              context: { recommendation: 'Enable encryption at rest and in transit' }
            });
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A03_INJECTION_ADVANCED',
        name: 'Advanced Injection Attacks',
        description: 'Detects NoSQL, LDAP, and OS command injection vulnerabilities',
        category: 'injection',
        owaspCategory: 'A03:2021 – Injection',
        severity: 'critical',
        enabled: true,
        patterns: [
          {
            type: 'regex',
            pattern: /\$where|\$ne|\$gt|\$lt|\$in|\$regex/g,
            description: 'NoSQL injection patterns'
          },
          {
            type: 'regex',
            pattern: /exec\(|system\(|shell_exec\(|passthru\(/g,
            description: 'OS command injection patterns'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for NoSQL injection vulnerabilities
          if (provider.type === 'database' && (provider.constructor.name.includes('Mongo') || provider.constructor.name.includes('Couch'))) {
            if (!config.security?.nosqlInjectionProtection) {
              findings.push({
                ruleId: 'OWASP_A03_INJECTION_ADVANCED',
                location: 'NoSQL database provider',
                evidence: 'NoSQL injection protection not configured',
                confidence: 'medium',
                context: { providerType: 'NoSQL', recommendation: 'Implement query sanitization' }
              });
            }
          }

          // Check for command injection in system operations
          const providerCode = provider.toString();
          const commandPatterns = ['exec(', 'system(', 'shell_exec(', 'child_process.exec'];
          
          for (const pattern of commandPatterns) {
            if (providerCode.includes(pattern)) {
              findings.push({
                ruleId: 'OWASP_A03_INJECTION_ADVANCED',
                location: 'provider implementation',
                evidence: `Potential command injection via ${pattern}`,
                confidence: 'medium',
                context: { pattern, recommendation: 'Use parameterized system calls' }
              });
            }
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A05_SECURITY_MISCONFIG',
        name: 'Security Misconfiguration',
        description: 'Identifies security misconfigurations',
        category: 'security_misconfiguration',
        owaspCategory: 'A05:2021 – Security Misconfiguration',
        severity: 'high',
        enabled: true,
        patterns: [
          {
            type: 'configuration',
            pattern: 'debug',
            description: 'Debug mode enabled in production'
          },
          {
            type: 'configuration',
            pattern: 'cors',
            description: 'CORS misconfiguration'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for debug mode in production
          if (config.debug === true || config.NODE_ENV === 'development') {
            findings.push({
              ruleId: 'OWASP_A05_SECURITY_MISCONFIG',
              location: 'environment configuration',
              evidence: 'Debug mode or development environment detected',
              confidence: 'high',
              context: { recommendation: 'Disable debug mode in production' }
            });
          }

          // Check for overly permissive CORS
          if (config.cors && config.cors.origin === '*') {
            findings.push({
              ruleId: 'OWASP_A05_SECURITY_MISCONFIG',
              location: 'CORS configuration',
              evidence: 'Overly permissive CORS policy allowing all origins',
              confidence: 'high',
              context: { recommendation: 'Restrict CORS to specific trusted origins' }
            });
          }

          // Check for default credentials
          const configString = JSON.stringify(config).toLowerCase();
          const defaultPasswords = ['admin', 'password', '123456', 'root'];
          
          for (const password of defaultPasswords) {
            if (configString.includes(`"password":"${password}"`) || configString.includes(`"pass":"${password}"`)) {
              findings.push({
                ruleId: 'OWASP_A05_SECURITY_MISCONFIG',
                location: 'authentication configuration',
                evidence: `Default password detected: ${password}`,
                confidence: 'critical',
                context: { recommendation: 'Change all default passwords immediately' }
              });
            }
          }

          // Check for missing security headers
          if (!config.security || !config.security.headers) {
            findings.push({
              ruleId: 'OWASP_A05_SECURITY_MISCONFIG',
              location: 'security headers configuration',
              evidence: 'Security headers not configured',
              confidence: 'medium',
              context: { 
                recommendation: 'Configure security headers (CSP, HSTS, X-Frame-Options, etc.)',
                headers: ['Content-Security-Policy', 'Strict-Transport-Security', 'X-Frame-Options', 'X-Content-Type-Options']
              }
            });
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A06_VULNERABLE_COMPONENTS',
        name: 'Vulnerable and Outdated Components',
        description: 'Identifies known vulnerable dependencies',
        category: 'using_components_with_known_vulnerabilities',
        owaspCategory: 'A06:2021 – Vulnerable and Outdated Components',
        severity: 'high',
        enabled: true,
        patterns: [
          {
            type: 'dependency',
            pattern: 'package.json',
            description: 'Outdated or vulnerable npm packages'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for known vulnerable packages (simplified check)
          const knownVulnerablePackages = [
            { name: 'lodash', versions: ['<4.17.19'], cve: 'CVE-2020-8203' },
            { name: 'moment', versions: ['<2.29.1'], cve: 'CVE-2020-15240' },
            { name: 'express', versions: ['<4.17.1'], cve: 'CVE-2019-5413' },
            { name: 'mongoose', versions: ['<5.7.5'], cve: 'CVE-2019-17426' }
          ];

          // This would typically integrate with npm audit or vulnerability databases
          const dependencies = config.dependencies || {};
          
          for (const pkg of knownVulnerablePackages) {
            if (dependencies[pkg.name]) {
              findings.push({
                ruleId: 'OWASP_A06_VULNERABLE_COMPONENTS',
                location: `dependency: ${pkg.name}`,
                evidence: `Known vulnerable package detected: ${pkg.name} (${pkg.cve})`,
                confidence: 'high',
                context: { 
                  package: pkg.name,
                  cve: pkg.cve,
                  recommendation: `Update ${pkg.name} to a secure version`
                }
              });
            }
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A07_AUTH_FAILURES',
        name: 'Identification and Authentication Failures',
        description: 'Detects authentication and session management vulnerabilities',
        category: 'broken_authentication',
        owaspCategory: 'A07:2021 – Identification and Authentication Failures',
        severity: 'critical',
        enabled: true,
        patterns: [
          {
            type: 'configuration',
            pattern: 'session',
            description: 'Session configuration issues'
          },
          {
            type: 'configuration',
            pattern: 'authentication',
            description: 'Authentication configuration'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for weak session configuration
          if (config.session) {
            if (!config.session.secure) {
              findings.push({
                ruleId: 'OWASP_A07_AUTH_FAILURES',
                location: 'session configuration',
                evidence: 'Session cookies not marked as secure',
                confidence: 'high',
                context: { recommendation: 'Enable secure flag for session cookies' }
              });
            }

            if (!config.session.httpOnly) {
              findings.push({
                ruleId: 'OWASP_A07_AUTH_FAILURES',
                location: 'session configuration',
                evidence: 'Session cookies not marked as httpOnly',
                confidence: 'high',
                context: { recommendation: 'Enable httpOnly flag for session cookies' }
              });
            }

            if (!config.session.maxAge || config.session.maxAge > 24 * 60 * 60 * 1000) {
              findings.push({
                ruleId: 'OWASP_A07_AUTH_FAILURES',
                location: 'session configuration',
                evidence: 'Session timeout too long or not configured',
                confidence: 'medium',
                context: { recommendation: 'Set appropriate session timeout (recommended: <24 hours)' }
              });
            }
          }

          // Check for missing MFA
          if (provider.type === 'authentication' && (!config.mfa || !config.mfa.enabled)) {
            findings.push({
              ruleId: 'OWASP_A07_AUTH_FAILURES',
              location: 'authentication provider',
              evidence: 'Multi-factor authentication not enabled',
              confidence: 'high',
              context: { recommendation: 'Implement multi-factor authentication' }
            });
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A09_LOGGING_MONITORING',
        name: 'Security Logging and Monitoring Failures',
        description: 'Identifies insufficient logging and monitoring',
        category: 'insufficient_logging_monitoring',
        owaspCategory: 'A09:2021 – Security Logging and Monitoring Failures',
        severity: 'medium',
        enabled: true,
        patterns: [
          {
            type: 'configuration',
            pattern: 'logging',
            description: 'Logging configuration'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          // Check for missing security event logging
          if (!config.logging || !config.logging.securityEvents) {
            findings.push({
              ruleId: 'OWASP_A09_LOGGING_MONITORING',
              location: 'logging configuration',
              evidence: 'Security event logging not configured',
              confidence: 'medium',
              context: { 
                recommendation: 'Enable logging for authentication, authorization, and security events',
                events: ['login_attempts', 'privilege_escalation', 'data_access', 'configuration_changes']
              }
            });
          }

          // Check for missing log monitoring
          if (!config.monitoring || !config.monitoring.logs) {
            findings.push({
              ruleId: 'OWASP_A09_LOGGING_MONITORING',
              location: 'monitoring configuration',
              evidence: 'Log monitoring and alerting not configured',
              confidence: 'medium',
              context: { recommendation: 'Implement real-time log monitoring and alerting' }
            });
          }

          return findings;
        }
      },

      {
        id: 'OWASP_A10_SSRF',
        name: 'Server-Side Request Forgery',
        description: 'Detects potential SSRF vulnerabilities',
        category: 'server_side_request_forgery',
        owaspCategory: 'A10:2021 – Server-Side Request Forgery',
        severity: 'high',
        enabled: true,
        patterns: [
          {
            type: 'function',
            pattern: (code: string) => {
              return code.includes('fetch(') || code.includes('request(') || code.includes('http.get');
            },
            description: 'HTTP request functions that may be vulnerable to SSRF'
          }
        ],
        scan: async (provider, config, context) => {
          const findings: VulnerabilityFinding[] = [];

          const providerCode = provider.toString();
          
          // Check for unvalidated HTTP requests
          if (providerCode.includes('fetch(') || providerCode.includes('request(')) {
            if (!config.security?.urlValidation) {
              findings.push({
                ruleId: 'OWASP_A10_SSRF',
                location: 'HTTP request handling',
                evidence: 'HTTP requests without URL validation detected',
                confidence: 'medium',
                context: { 
                  recommendation: 'Implement URL validation and allowlisting for external requests',
                  patterns: ['fetch(', 'request(', 'axios.get', 'http.get']
                }
              });
            }
          }

          return findings;
        }
      }
    ];

    // Register all rules
    for (const rule of rules) {
      this.rules.set(rule.id, rule);
    }
  }

  /**
   * Load CVE database (simplified implementation)
   */
  private async loadCveDatabase(): Promise<void> {
    // In a real implementation, this would load from NIST NVD, GitHub Security Advisories, etc.
    const mockCveData = [
      {
        id: 'CVE-2020-8203',
        description: 'Prototype pollution in lodash',
        severity: 'high',
        vector: { network: 'network', complexity: 'low', authentication: 'none' },
        impact: { confidentiality: 'partial', integrity: 'partial', availability: 'partial' }
      },
      {
        id: 'CVE-2020-15240',
        description: 'ReDoS vulnerability in moment.js',
        severity: 'medium',
        vector: { network: 'network', complexity: 'low', authentication: 'none' },
        impact: { confidentiality: 'none', integrity: 'none', availability: 'partial' }
      }
    ];

    for (const cve of mockCveData) {
      this.cveDatabase.set(cve.id, cve);
    }
  }

  /**
   * Scan a provider for vulnerabilities
   */
  async scanProvider(
    providerId: string,
    providerType: string,
    provider: any,
    config: any,
    options: {
      scanType?: 'static' | 'dynamic' | 'interactive' | 'dependency';
      depth?: 'surface' | 'deep' | 'comprehensive';
      includeExperimental?: boolean;
      ruleIds?: string[];
      suppressedFindings?: string[];
    } = {}
  ): Promise<ScanResult> {
    const scanId = `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();

    const context: ScanContext = {
      providerId,
      providerType,
      scanType: options.scanType || 'static',
      depth: options.depth || 'deep',
      includeExperimental: options.includeExperimental || false
    };

    const vulnerabilities: Vulnerability[] = [];
    const findings: VulnerabilityFinding[] = [];

    // Filter rules based on options
    const rulesToRun = options.ruleIds
      ? Array.from(this.rules.values()).filter(rule => options.ruleIds!.includes(rule.id))
      : Array.from(this.rules.values()).filter(rule => rule.enabled);

    // Run vulnerability rules
    for (const rule of rulesToRun) {
      try {
        this.emit('rule-started', { scanId, ruleId: rule.id });
        
        const ruleFindings = await rule.scan(provider, config, context);
        findings.push(...ruleFindings);

        this.emit('rule-completed', { scanId, ruleId: rule.id, findingsCount: ruleFindings.length });
      } catch (error) {
        this.emit('rule-error', { scanId, ruleId: rule.id, error: error.message });
      }
    }

    // Convert findings to vulnerabilities
    for (const finding of findings) {
      const rule = this.rules.get(finding.ruleId);
      if (rule) {
        const vulnerability = await this.createVulnerabilityFromFinding(finding, rule, context);
        vulnerabilities.push(vulnerability);
      }
    }

    // Filter suppressed findings
    const filteredVulnerabilities = vulnerabilities.filter(vuln => 
      !this.suppressedFindings.has(vuln.id) &&
      !(options.suppressedFindings?.includes(vuln.id))
    );

    const duration = Date.now() - startTime;
    const summary = this.calculateScanSummary(filteredVulnerabilities);
    const recommendations = this.generateRecommendations(filteredVulnerabilities);

    const scanResult: ScanResult = {
      scanId,
      providerId,
      providerType,
      timestamp: new Date(),
      duration,
      context,
      vulnerabilities: filteredVulnerabilities,
      summary,
      recommendations,
      nextScanDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    };

    // Store scan history
    this.scanHistory.push(scanResult);
    this.emit('scan-completed', scanResult);

    return scanResult;
  }

  /**
   * Create vulnerability from finding
   */
  private async createVulnerabilityFromFinding(
    finding: VulnerabilityFinding,
    rule: VulnerabilityRule,
    context: ScanContext
  ): Promise<Vulnerability> {
    const vulnerabilityId = createHash('sha256')
      .update(`${finding.ruleId}_${finding.location}_${finding.evidence}`)
      .digest('hex')
      .substring(0, 16);

    // Look up CVE information if available
    const cveInfo = Array.from(this.cveDatabase.values()).find(cve => 
      finding.evidence.toLowerCase().includes(cve.description.toLowerCase().split(' ')[0])
    );

    const vulnerability: Vulnerability = {
      id: vulnerabilityId,
      cveId: cveInfo?.id,
      owaspId: rule.owaspCategory,
      title: rule.name,
      description: `${rule.description}: ${finding.evidence}`,
      severity: rule.severity,
      category: rule.category,
      vector: cveInfo?.vector || {
        network: 'network',
        complexity: 'low',
        authentication: 'none'
      },
      impact: cveInfo?.impact || {
        confidentiality: 'partial',
        integrity: 'partial',
        availability: 'none',
        scope: 'unchanged',
        privilegesRequired: 'none',
        userInteraction: 'none'
      },
      exploitability: this.assessExploitability(finding, rule),
      remediationLevel: 'official_fix',
      reportConfidence: finding.confidence === 'high' ? 'confirmed' : 
                      finding.confidence === 'medium' ? 'reasonable' : 'unknown',
      discoveredAt: new Date(),
      lastUpdated: new Date(),
      affectedComponents: [context.providerId],
      references: this.generateReferences(rule, cveInfo),
      remediation: this.generateRemediationGuidance(finding, rule)
    };

    return vulnerability;
  }

  /**
   * Assess exploitability level
   */
  private assessExploitability(
    finding: VulnerabilityFinding,
    rule: VulnerabilityRule
  ): Vulnerability['exploitability'] {
    if (rule.severity === 'critical' && finding.confidence === 'high') {
      return 'functional';
    }
    if (rule.severity === 'high' && finding.confidence === 'high') {
      return 'proof_of_concept';
    }
    if (finding.confidence === 'medium') {
      return 'unproven';
    }
    return 'not_defined';
  }

  /**
   * Generate vulnerability references
   */
  private generateReferences(rule: VulnerabilityRule, cveInfo?: any): string[] {
    const references: string[] = [];

    // OWASP references
    references.push(`https://owasp.org/Top10/A01_2021-Broken_Access_Control/`);

    // CVE references
    if (cveInfo) {
      references.push(`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveInfo.id}`);
      references.push(`https://nvd.nist.gov/vuln/detail/${cveInfo.id}`);
    }

    // Category-specific references
    switch (rule.category) {
      case 'injection':
        references.push('https://owasp.org/www-community/Injection_Flaws');
        break;
      case 'broken_authentication':
        references.push('https://owasp.org/www-community/Broken_Authentication_and_Session_Management');
        break;
      case 'sensitive_data_exposure':
        references.push('https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url');
        break;
      case 'security_misconfiguration':
        references.push('https://owasp.org/www-community/vulnerabilities/Configuration');
        break;
    }

    return references;
  }

  /**
   * Generate remediation guidance
   */
  private generateRemediationGuidance(
    finding: VulnerabilityFinding,
    rule: VulnerabilityRule
  ): RemediationGuidance {
    const baseGuidance = {
      steps: [],
      patches: [],
      workarounds: [],
      timeline: 7, // days
      effort: 'medium' as const,
      cost: 'medium' as const,
      riskReduction: 80
    };

    // Add context-specific recommendations
    if (finding.context?.recommendation) {
      baseGuidance.steps.push(finding.context.recommendation);
    }

    // Add rule-specific guidance
    switch (rule.category) {
      case 'injection':
        baseGuidance.steps.push(
          'Implement parameterized queries or prepared statements',
          'Validate and sanitize all user inputs',
          'Use ORM frameworks with built-in injection protection',
          'Implement input validation at multiple layers'
        );
        baseGuidance.timeline = 3;
        baseGuidance.riskReduction = 95;
        break;

      case 'cryptographic_failures':
        baseGuidance.steps.push(
          'Upgrade to strong cryptographic algorithms (AES-256-GCM)',
          'Implement proper key management practices',
          'Enable encryption for data at rest and in transit',
          'Regular key rotation and secure key storage'
        );
        baseGuidance.timeline = 14;
        baseGuidance.effort = 'high';
        baseGuidance.riskReduction = 90;
        break;

      case 'security_misconfiguration':
        baseGuidance.steps.push(
          'Review and harden security configurations',
          'Remove default accounts and passwords',
          'Disable unnecessary services and features',
          'Implement security configuration baselines'
        );
        baseGuidance.timeline = 7;
        baseGuidance.effort = 'low';
        baseGuidance.cost = 'low';
        break;

      case 'broken_authentication':
        baseGuidance.steps.push(
          'Implement multi-factor authentication',
          'Configure secure session management',
          'Implement account lockout policies',
          'Use strong password policies'
        );
        baseGuidance.timeline = 10;
        baseGuidance.riskReduction = 85;
        break;

      default:
        baseGuidance.steps.push(
          'Review security documentation for specific guidance',
          'Consult security team for remediation plan',
          'Implement defense-in-depth security measures'
        );
    }

    return baseGuidance;
  }

  /**
   * Calculate scan summary
   */
  private calculateScanSummary(vulnerabilities: Vulnerability[]): ScanSummary {
    const total = vulnerabilities.length;
    const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
    const high = vulnerabilities.filter(v => v.severity === 'high').length;
    const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
    const low = vulnerabilities.filter(v => v.severity === 'low').length;
    const info = vulnerabilities.filter(v => v.severity === 'info').length;
    const confirmed = vulnerabilities.filter(v => v.reportConfidence === 'confirmed').length;

    // Calculate risk score (0-100)
    const riskScore = Math.min(100, (critical * 25) + (high * 10) + (medium * 5) + (low * 2));

    return {
      total,
      critical,
      high,
      medium,
      low,
      info,
      confirmed,
      suppressed: 0,
      falsePositives: 0,
      riskScore
    };
  }

  /**
   * Generate recommendations based on vulnerabilities
   */
  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations = new Set<string>();

    // Priority-based recommendations
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      recommendations.add('Address all critical vulnerabilities immediately');
      recommendations.add('Implement emergency security patches');
    }

    const highVulns = vulnerabilities.filter(v => v.severity === 'high');
    if (highVulns.length > 0) {
      recommendations.add('Plan remediation for high-severity vulnerabilities within 7 days');
    }

    // Category-based recommendations
    const categories = new Set(vulnerabilities.map(v => v.category));
    
    if (categories.has('injection')) {
      recommendations.add('Implement comprehensive input validation and parameterized queries');
    }
    
    if (categories.has('cryptographic_failures')) {
      recommendations.add('Upgrade cryptographic implementations to use strong algorithms');
    }
    
    if (categories.has('security_misconfiguration')) {
      recommendations.add('Review and harden all security configurations');
    }

    if (categories.has('broken_authentication')) {
      recommendations.add('Strengthen authentication mechanisms and implement MFA');
    }

    // General recommendations
    recommendations.add('Implement regular vulnerability scanning');
    recommendations.add('Establish security monitoring and incident response procedures');
    recommendations.add('Conduct security training for development team');

    return Array.from(recommendations);
  }

  /**
   * Generate vulnerability report
   */
  async generateVulnerabilityReport(
    scanResults: ScanResult[],
    options: {
      format?: 'json' | 'html' | 'pdf' | 'sarif';
      includeSuppressed?: boolean;
      severity?: ('critical' | 'high' | 'medium' | 'low')[];
      groupBy?: 'provider' | 'severity' | 'category';
    } = {}
  ): Promise<string> {
    const reportPath = path.join(
      process.cwd(),
      'vulnerability-reports',
      `vulnerability-report-${Date.now()}.${options.format || 'json'}`
    );

    let filteredResults = scanResults;

    // Filter by severity if specified
    if (options.severity) {
      filteredResults = scanResults.map(result => ({
        ...result,
        vulnerabilities: result.vulnerabilities.filter(v => options.severity!.includes(v.severity))
      }));
    }

    const report = {
      generatedAt: new Date().toISOString(),
      summary: {
        totalScans: filteredResults.length,
        totalVulnerabilities: filteredResults.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
        criticalVulnerabilities: filteredResults.reduce((sum, r) => sum + r.summary.critical, 0),
        highVulnerabilities: filteredResults.reduce((sum, r) => sum + r.summary.high, 0),
        averageRiskScore: filteredResults.reduce((sum, r) => sum + r.summary.riskScore, 0) / filteredResults.length,
        topCategories: this.getTopVulnerabilityCategories(filteredResults),
        remediationTimeline: this.estimateRemediationTimeline(filteredResults)
      },
      scans: filteredResults,
      recommendations: this.consolidateVulnerabilityRecommendations(filteredResults),
      metrics: this.calculateSecurityMetrics(filteredResults)
    };

    // Ensure directory exists
    await fs.mkdir(path.dirname(reportPath), { recursive: true });

    // Generate report based on format
    switch (options.format) {
      case 'sarif':
        await this.generateSarifReport(report, reportPath);
        break;
      case 'html':
        await this.generateHtmlVulnerabilityReport(report, reportPath);
        break;
      default:
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
    }

    this.emit('report-generated', { reportPath, summary: report.summary });

    return reportPath;
  }

  /**
   * Generate SARIF format report
   */
  private async generateSarifReport(report: any, reportPath: string): Promise<void> {
    const sarif = {
      version: '2.1.0',
      $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
      runs: report.scans.map((scan: ScanResult) => ({
        tool: {
          driver: {
            name: 'RSVP Platform Vulnerability Scanner',
            version: '1.0.0',
            informationUri: 'https://github.com/rsvp-platform/security-scanner'
          }
        },
        results: scan.vulnerabilities.map((vuln: Vulnerability) => ({
          ruleId: vuln.id,
          message: { text: vuln.description },
          level: this.mapSeverityToSarifLevel(vuln.severity),
          locations: [{
            physicalLocation: {
              artifactLocation: { uri: vuln.affectedComponents[0] },
              region: { startLine: 1 }
            }
          }],
          properties: {
            cveId: vuln.cveId,
            owaspId: vuln.owaspId,
            category: vuln.category,
            remediation: vuln.remediation.steps
          }
        }))
      }))
    };

    await fs.writeFile(reportPath, JSON.stringify(sarif, null, 2));
  }

  /**
   * Map severity to SARIF level
   */
  private mapSeverityToSarifLevel(severity: string): string {
    switch (severity) {
      case 'critical': return 'error';
      case 'high': return 'error';
      case 'medium': return 'warning';
      case 'low': return 'note';
      default: return 'info';
    }
  }

  /**
   * Generate HTML vulnerability report
   */
  private async generateHtmlVulnerabilityReport(report: any, reportPath: string): Promise<void> {
    const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; }
        .critical { border-left: 5px solid #d32f2f; }
        .high { border-left: 5px solid #f57c00; }
        .medium { border-left: 5px solid #1976d2; }
        .low { border-left: 5px solid #388e3c; }
        .remediation { background: #e3f2fd; padding: 10px; margin: 10px 0; }
        .metric { display: inline-block; margin: 10px; padding: 10px; background: #fff; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    </style>
</head>
<body>
    <h1>Vulnerability Assessment Report</h1>
    <div class="summary">
        <h2>Executive Summary</h2>
        <div class="metric">
            <h3>${report.summary.totalVulnerabilities}</h3>
            <p>Total Vulnerabilities</p>
        </div>
        <div class="metric">
            <h3>${report.summary.criticalVulnerabilities}</h3>
            <p>Critical</p>
        </div>
        <div class="metric">
            <h3>${report.summary.highVulnerabilities}</h3>
            <p>High</p>
        </div>
        <div class="metric">
            <h3>${report.summary.averageRiskScore.toFixed(1)}</h3>
            <p>Average Risk Score</p>
        </div>
    </div>
    
    <h2>Vulnerability Details</h2>
    ${report.scans.map((scan: ScanResult) => `
        <h3>Provider: ${scan.providerId}</h3>
        ${scan.vulnerabilities.map((vuln: Vulnerability) => `
            <div class="vulnerability ${vuln.severity}">
                <h4>${vuln.title}</h4>
                <p><strong>Severity:</strong> ${vuln.severity.toUpperCase()}</p>
                <p><strong>Category:</strong> ${vuln.category}</p>
                <p><strong>Description:</strong> ${vuln.description}</p>
                ${vuln.cveId ? `<p><strong>CVE:</strong> ${vuln.cveId}</p>` : ''}
                <div class="remediation">
                    <h5>Remediation Steps:</h5>
                    <ul>
                        ${vuln.remediation.steps.map((step: string) => `<li>${step}</li>`).join('')}
                    </ul>
                    <p><strong>Timeline:</strong> ${vuln.remediation.timeline} days</p>
                    <p><strong>Effort:</strong> ${vuln.remediation.effort}</p>
                </div>
            </div>
        `).join('')}
    `).join('')}
    
    <h2>Recommendations</h2>
    <ul>
        ${report.recommendations.map((rec: string) => `<li>${rec}</li>`).join('')}
    </ul>
</body>
</html>`;

    await fs.writeFile(reportPath, html);
  }

  /**
   * Get top vulnerability categories
   */
  private getTopVulnerabilityCategories(scanResults: ScanResult[]): Array<{category: string, count: number}> {
    const categoryCounts = new Map<string, number>();

    scanResults.forEach(scan => {
      scan.vulnerabilities.forEach(vuln => {
        categoryCounts.set(vuln.category, (categoryCounts.get(vuln.category) || 0) + 1);
      });
    });

    return Array.from(categoryCounts.entries())
      .map(([category, count]) => ({ category, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
  }

  /**
   * Estimate overall remediation timeline
   */
  private estimateRemediationTimeline(scanResults: ScanResult[]): number {
    const allVulns = scanResults.flatMap(scan => scan.vulnerabilities);
    if (allVulns.length === 0) return 0;

    return Math.max(...allVulns.map(vuln => vuln.remediation.timeline));
  }

  /**
   * Consolidate vulnerability recommendations
   */
  private consolidateVulnerabilityRecommendations(scanResults: ScanResult[]): string[] {
    const recommendations = new Set<string>();

    scanResults.forEach(scan => {
      scan.recommendations.forEach(rec => recommendations.add(rec));
    });

    return Array.from(recommendations).sort();
  }

  /**
   * Calculate security metrics
   */
  private calculateSecurityMetrics(scanResults: ScanResult[]): any {
    const allVulns = scanResults.flatMap(scan => scan.vulnerabilities);
    
    return {
      meanTimeToDetection: 0, // Would be calculated based on discovery timestamps
      meanTimeToRemediation: allVulns.reduce((sum, v) => sum + v.remediation.timeline, 0) / allVulns.length,
      vulnerabilityDensity: allVulns.length / scanResults.length,
      securityCoverage: (scanResults.length / scanResults.length) * 100, // Simplified
      riskTrend: 'stable' // Would be calculated based on historical data
    };
  }

  /**
   * Suppress vulnerability finding
   */
  suppressFinding(vulnerabilityId: string, reason: string): void {
    this.suppressedFindings.add(vulnerabilityId);
    this.emit('finding-suppressed', { vulnerabilityId, reason });
  }

  /**
   * Unsuppress vulnerability finding
   */
  unsuppressFinding(vulnerabilityId: string): void {
    this.suppressedFindings.delete(vulnerabilityId);
    this.emit('finding-unsuppressed', { vulnerabilityId });
  }

  /**
   * Get scan history
   */
  getScanHistory(providerId?: string): ScanResult[] {
    return providerId 
      ? this.scanHistory.filter(scan => scan.providerId === providerId)
      : this.scanHistory;
  }

  /**
   * Get vulnerability rule by ID
   */
  getRule(ruleId: string): VulnerabilityRule | undefined {
    return this.rules.get(ruleId);
  }

  /**
   * Add custom vulnerability rule
   */
  addCustomRule(rule: VulnerabilityRule): void {
    this.rules.set(rule.id, rule);
    this.emit('rule-added', rule);
  }

  /**
   * Update vulnerability rule
   */
  updateRule(ruleId: string, updates: Partial<VulnerabilityRule>): boolean {
    const existing = this.rules.get(ruleId);
    if (existing) {
      this.rules.set(ruleId, { ...existing, ...updates });
      this.emit('rule-updated', { ruleId, updates });
      return true;
    }
    return false;
  }

  /**
   * Remove vulnerability rule
   */
  removeRule(ruleId: string): boolean {
    const removed = this.rules.delete(ruleId);
    if (removed) {
      this.emit('rule-removed', ruleId);
    }
    return removed;
  }
}